using System;
using System.Collections.Immutable;
using System.Text;
using AlexaVoxCraft.MediatR.Generators.Models;

namespace AlexaVoxCraft.MediatR.Generators.Generators;

internal static class InterceptorEmitter
{
    public static string EmitInterceptors(ImmutableArray<InterceptorLocation> locations, RegistrationModel model)
    {
        var sb = new StringBuilder();

        sb.AppendLine("// <auto-generated />");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();

        EmitInterceptsLocationAttribute(sb);

        sb.AppendLine("namespace AlexaVoxCraft.Generated");
        sb.AppendLine("{");
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Diagnostics;");
        sb.AppendLine("using System.Runtime.CompilerServices;");
        sb.AppendLine("using Microsoft.Extensions.Configuration;");
        sb.AppendLine("using Microsoft.Extensions.DependencyInjection;");
        sb.AppendLine("using Microsoft.Extensions.DependencyInjection.Extensions;");
        sb.AppendLine();
        sb.AppendLine("file static class AlexaVoxCraftInterceptors");
        sb.AppendLine("{");

        // Emit all InterceptsLocation attributes
        foreach (var location in locations)
        {
            sb.AppendLine($"    [InterceptsLocation(version: 1, data: \"{location.Data}\")]");
        }

        // Emit single method that handles all call sites
        sb.AppendLine("    internal static IServiceCollection AddSkillMediator(");
        sb.AppendLine("        this IServiceCollection services,");
        sb.AppendLine("        IConfiguration configuration,");
        sb.AppendLine("        Action<AlexaVoxCraft.MediatR.DI.SkillServiceConfiguration>? settingsAction = null,");
        sb.AppendLine("        string sectionName = AlexaVoxCraft.MediatR.DI.SkillServiceConfiguration.SectionName)");
        sb.AppendLine("    {");
        sb.AppendLine("        // Build effective configuration");
        sb.AppendLine("        var cfg = new AlexaVoxCraft.MediatR.DI.SkillServiceConfiguration();");
        sb.AppendLine("        configuration.GetSection(sectionName).Bind(cfg);");
        sb.AppendLine("        settingsAction?.Invoke(cfg);");
        sb.AppendLine();
        sb.AppendLine("        // Register configuration with DI to enable IOptions<SkillServiceConfiguration>");
        sb.AppendLine("        services.Configure<AlexaVoxCraft.MediatR.DI.SkillServiceConfiguration>(opt =>");
        sb.AppendLine("        {");
        sb.AppendLine("            configuration.GetSection(sectionName).Bind(opt);");
        sb.AppendLine("            settingsAction?.Invoke(opt);");
        sb.AppendLine("        });");
        sb.AppendLine();
        sb.AppendLine("        // Add required core services");
        sb.AppendLine("        AlexaVoxCraft.MediatR.Registration.ServiceRegistrar.AddRequiredServices(services, cfg);");
        sb.AppendLine();

        EmitHandlerRegistrations(sb, model);
        EmitBehaviorRegistrations(sb, model);
        EmitExceptionHandlerRegistrations(sb, model);
        EmitInterceptorRegistrations(sb, model);
        EmitPersistenceAdapterRegistration(sb, model);

        sb.AppendLine("        return services;");
        sb.AppendLine("    }");

        sb.AppendLine("}");
        sb.AppendLine("}");

        return sb.ToString();
    }

    private static void EmitInterceptsLocationAttribute(StringBuilder sb)
    {
        sb.AppendLine("namespace System.Runtime.CompilerServices");
        sb.AppendLine("{");
        sb.AppendLine("    [AttributeUsage(AttributeTargets.Method, AllowMultiple = true)]");
        sb.AppendLine("    file sealed class InterceptsLocationAttribute : Attribute");
        sb.AppendLine("    {");
        sb.AppendLine("        public InterceptsLocationAttribute(int version, string data)");
        sb.AppendLine("        {");
        sb.AppendLine("        }");
        sb.AppendLine("    }");
        sb.AppendLine("}");
        sb.AppendLine();
    }

    private static void EmitHandlerRegistrations(StringBuilder sb, RegistrationModel model)
    {
        if (model.Handlers.Count == 0 && model.DefaultHandler == null)
            return;

        sb.AppendLine("        // Request Handlers");

        foreach (var handler in model.Handlers)
        {
            var method = ToLifetimeMethod(handler.Lifetime);
            var typeName = handler.Type.FullyQualifiedName;

            if (handler.RequestType != null)
            {
                var requestTypeName = handler.RequestType.Value.FullyQualifiedName;
                sb.AppendLine($"        services.{method}<AlexaVoxCraft.MediatR.IRequestHandler<{requestTypeName}>, {typeName}>();");
            }
            else
            {
                sb.AppendLine($"        services.{method}<AlexaVoxCraft.MediatR.IRequestHandler, {typeName}>();");
            }
        }

        if (model.DefaultHandler != null)
        {
            var typeName = model.DefaultHandler.Value.Type.FullyQualifiedName;
            sb.AppendLine($"        services.TryAddTransient<AlexaVoxCraft.MediatR.IDefaultRequestHandler, {typeName}>();");
        }

        sb.AppendLine();
    }

    private static void EmitBehaviorRegistrations(StringBuilder sb, RegistrationModel model)
    {
        if (model.Behaviors.Count == 0)
            return;

        sb.AppendLine("        // Pipeline Behaviors (ordered by Order property)");

        foreach (var behavior in model.Behaviors)
        {
            var method = ToLifetimeMethod(behavior.Lifetime);
            var typeName = behavior.Type.FullyQualifiedName;
            sb.AppendLine($"        services.{method}<AlexaVoxCraft.MediatR.Pipeline.IPipelineBehavior, {typeName}>(); // Order={behavior.Order}");
        }

        sb.AppendLine();
    }

    private static void EmitExceptionHandlerRegistrations(StringBuilder sb, RegistrationModel model)
    {
        if (model.ExceptionHandlers.Count == 0)
            return;

        sb.AppendLine("        // Exception Handlers");

        foreach (var handler in model.ExceptionHandlers)
        {
            var method = ToLifetimeMethod(handler.Lifetime);
            var typeName = handler.Type.FullyQualifiedName;
            sb.AppendLine($"        services.{method}<AlexaVoxCraft.MediatR.Pipeline.IExceptionHandler, {typeName}>();");
        }

        sb.AppendLine();
    }

    private static void EmitInterceptorRegistrations(StringBuilder sb, RegistrationModel model)
    {
        if (model.RequestInterceptors.Count == 0 && model.ResponseInterceptors.Count == 0)
            return;

        if (model.RequestInterceptors.Count > 0)
        {
            sb.AppendLine("        // Request Interceptors");

            foreach (var interceptor in model.RequestInterceptors)
            {
                var method = ToLifetimeMethod(interceptor.Lifetime);
                var typeName = interceptor.Type.FullyQualifiedName;
                sb.AppendLine($"        services.{method}<AlexaVoxCraft.MediatR.Pipeline.IRequestInterceptor, {typeName}>();");
            }

            sb.AppendLine();
        }

        if (model.ResponseInterceptors.Count > 0)
        {
            sb.AppendLine("        // Response Interceptors");

            foreach (var interceptor in model.ResponseInterceptors)
            {
                var method = ToLifetimeMethod(interceptor.Lifetime);
                var typeName = interceptor.Type.FullyQualifiedName;
                sb.AppendLine($"        services.{method}<AlexaVoxCraft.MediatR.Pipeline.IResponseInterceptor, {typeName}>();");
            }

            sb.AppendLine();
        }
    }

    private static void EmitPersistenceAdapterRegistration(StringBuilder sb, RegistrationModel model)
    {
        if (model.PersistenceAdapter == null)
            return;

        sb.AppendLine("        // Persistence Adapter");

        var typeName = model.PersistenceAdapter.Value.Type.FullyQualifiedName;
        sb.AppendLine($"        services.TryAddSingleton<AlexaVoxCraft.MediatR.Attributes.Persistence.IPersistenceAdapter, {typeName}>();");

        sb.AppendLine();
    }

    private static string ToLifetimeMethod(int lifetime)
    {
        return lifetime switch
        {
            0 => "AddSingleton",
            1 => "AddScoped",
            _ => "AddTransient"
        };
    }
}